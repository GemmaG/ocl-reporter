Mirari takes a single configuration file and splits the lifecycle of a Mirage application into three distinct segments:

* configuration: it scans the config file, checks for any missing OPAM packages, and installs them if missing.  It also looks for any filesystem directives and calls mir-crunch to generate the static ML files.  All of this is glued together into an autogenerated main.ml which is the entry point for the application.

* build: it runs the OCaml build (via Vincent's obuild), and then issues any backend-specific commands (such as the Xen link, ocamlclean, or whatever else we dream up).

* run: this is being implemented.  Running a Mirage application is quite stateful: in the case of Xen, we want to monitor the kernel, attach a console, and so on.  Similarly for UNIX, one can imagine the socket version opening up a control channel for Mirari to listen on.  An in the kFreeBSD backend, this would be done via ioctls or other kernel/user interfaces.
